!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
KERNEL_VERSION	seeker.h	65;"	d
MAX_COUNTERS_PER_CPU	seeker.h	30;"	d
NUM_EXTRA_COUNTERS	seeker.h	29;"	d
PIDTAB_ENTRY	seeker.h	/^enum {SAMPLE_DEF, SEEKER_SAMPLE, PIDTAB_ENTRY};$/;"	e	enum:__anon1
PMU_ISR	probe.c	33;"	d	file:
SAMPLE_DEF	seeker.h	/^enum {SAMPLE_DEF, SEEKER_SAMPLE, PIDTAB_ENTRY};$/;"	e	enum:__anon1
SCHED_EXIT_EXISTS	probe.c	43;"	d	file:
SEEKER_SAMPLE	seeker.h	/^enum {SAMPLE_DEF, SEEKER_SAMPLE, PIDTAB_ENTRY};$/;"	e	enum:__anon1
SEEKER_SAMPLE_MINOR	main.c	45;"	d	file:
_SEEKER_SAMPLER_H_	seeker.h	26;"	d
__ALLOC_H_	alloc.h	26;"	d
__EXIT_H_	exit.h	26;"	d
__INTR_H_	intr.h	26;"	d
__LOG_H_	log.h	27;"	d
__PROBE_H_	probe.h	26;"	d
__SAMPLE_H_	sample.h	26;"	d
alloc_seeker	alloc.c	/^struct log_block * alloc_seeker(void)$/;"	f
clear_counters	sample.c	/^void clear_counters(void)$/;"	f
config_counters	sample.c	/^int config_counters(void)$/;"	f
configure_disable_interrupts	intr.c	/^void configure_disable_interrupts(void){$/;"	f
configure_enable_interrupts	intr.c	/^void configure_enable_interrupts(void){$/;"	f
counters	seeker.h	/^	unsigned char counters[MAX_COUNTERS_PER_CPU];$/;"	m	struct:__anon2
counters	seeker.h	/^	unsigned long long counters[MAX_COUNTERS_PER_CPU];$/;"	m	struct:__anon3
cpu	seeker.h	/^	unsigned int cpu;$/;"	m	struct:__anon3
cpu_counters	sample.c	/^int cpu_counters[NR_CPUS][MAX_COUNTERS_PER_CPU];$/;"	v
cpu_cycles	seeker.h	/^	unsigned long long cpu_cycles;$/;"	m	struct:__anon4
cpu_pid	sample.c	/^pid_t cpu_pid[NR_CPUS] = {-1};$/;"	v
cycles	seeker.h	/^	unsigned long long cycles;$/;"	m	struct:__anon3
debug	seeker.h	71;"	d
delete_log	log.c	/^void delete_log(struct log_block *ent)$/;"	f
dev_open	main.c	/^int dev_open = 0;$/;"	v
do_pid_log	sample.c	/^void do_pid_log(struct task_struct *p) $/;"	f
do_sample	sample.c	/^void do_sample(void) $/;"	f
do_timer_sample	intr.c	/^void do_timer_sample(unsigned long param){$/;"	f
enable_apic_pmu	intr.c	/^void enable_apic_pmu(void){$/;"	f
error	seeker.h	69;"	d
finalize_seeker_cache	alloc.c	/^void finalize_seeker_cache(void)$/;"	f
first_read	log.c	/^static int first_read = 1;$/;"	v	file:
free_seeker	alloc.c	/^void free_seeker(struct log_block * entry)$/;"	f
generic_close	io.c	/^int generic_close(struct inode *i, struct file *f) $/;"	f
generic_open	io.c	/^int generic_open(struct inode *i, struct file *f) $/;"	f
init_seeker_cache	alloc.c	/^int init_seeker_cache(void)$/;"	f
inst___switch_to	probe.c	/^void inst___switch_to(struct task_struct *from, struct task_struct *to){$/;"	f
inst_release_thread	probe.c	/^void inst_release_thread(struct task_struct *t){$/;"	f
inst_schedule	probe.c	/^int inst_schedule(struct kprobe *p, struct pt_regs *regs){$/;"	f
inst_smp_apic_pmu_interrupt	probe.c	/^void inst_smp_apic_pmu_interrupt(struct pt_regs *regs){$/;"	f
instr_sum	seeker.h	/^	unsigned long long instr_sum;$/;"	m	struct:__anon4
jp___switch_to	probe.c	/^struct jprobe jp___switch_to = {$/;"	v	typeref:struct:jprobe
jp_release_thread	probe.c	/^struct jprobe jp_release_thread = {$/;"	v	typeref:struct:jprobe
jp_smp_pmu_interrupt	probe.c	/^struct jprobe jp_smp_pmu_interrupt = {$/;"	v	typeref:struct:jprobe
kp_schedule	probe.c	/^struct kprobe kp_schedule = {$/;"	v	typeref:struct:kprobe
kprobes_registered	main.c	/^static int kprobes_registered = 0;$/;"	v	file:
log_block	alloc.h	/^struct log_block {$/;"	s
log_create	log.c	/^struct log_block *log_create(void)$/;"	f
log_ev_masks	main.c	/^unsigned int log_ev_masks[MAX_COUNTERS_PER_CPU];$/;"	v
log_events	main.c	/^int log_events[MAX_COUNTERS_PER_CPU];$/;"	v
log_finalize	log.c	/^void log_finalize(void)$/;"	f
log_init	log.c	/^void log_init(void)$/;"	f
log_link	log.c	/^void log_link(struct log_block * ent)$/;"	f
log_lock	log.c	/^static spinlock_t log_lock;$/;"	v	file:
log_num_events	main.c	/^int log_num_events = 0;$/;"	v
log_read	log.c	/^int log_read(struct file* file_ptr, $/;"	f
masks	seeker.h	/^	unsigned int masks[MAX_COUNTERS_PER_CPU];$/;"	m	struct:__anon2
mdev_registered	main.c	/^static int mdev_registered = 0;$/;"	v	file:
msrs_init	sample.c	/^int msrs_init(void)$/;"	f
name	seeker.h	/^	char name[16];$/;"	m	struct:__anon4
next	alloc.h	/^	struct log_block *next;$/;"	m	struct:log_block	typeref:struct:log_block::log_block
num_counters	seeker.h	/^	unsigned char num_counters;$/;"	m	struct:__anon2
os_flag	main.c	/^int os_flag = 0;$/;"	v
pid	seeker.h	/^	unsigned int pid;$/;"	m	struct:__anon3
pid	seeker.h	/^	unsigned int pid;$/;"	m	struct:__anon4
pidtab_entry	seeker.h	/^		pidtab_entry_t pidtab_entry;$/;"	m	union:__anon5::__anon6
pidtab_entry_t	seeker.h	/^} pidtab_entry_t;$/;"	t	typeref:struct:__anon4
pmu_intr	main.c	/^int pmu_intr = -1;$/;"	v
purge_log	log.c	/^void purge_log(void)$/;"	f
sample	alloc.h	/^	seeker_sampler_entry_t sample;$/;"	m	struct:log_block
sample_freq	main.c	/^int sample_freq=100;$/;"	v
sample_timer	intr.c	/^struct timer_list sample_timer;$/;"	v	typeref:struct:timer_list
sample_timer_started	intr.c	/^int sample_timer_started = 0;$/;"	v
seeker_cachep	alloc.c	/^static struct kmem_cache *seeker_cachep = NULL;$/;"	v	typeref:struct:kmem_cache	file:
seeker_log_current	log.c	/^struct log_block *seeker_log_current;$/;"	v	typeref:struct:log_block
seeker_log_head	log.c	/^struct log_block *seeker_log_head;$/;"	v	typeref:struct:log_block
seeker_sample	seeker.h	/^		seeker_sample_t seeker_sample;$/;"	m	union:__anon5::__anon6
seeker_sample_close	io.c	/^int seeker_sample_close(struct inode *in, struct file *f)$/;"	f
seeker_sample_def	seeker.h	/^		seeker_sample_def_t seeker_sample_def;$/;"	m	union:__anon5::__anon6
seeker_sample_def_t	seeker.h	/^} seeker_sample_def_t;$/;"	t	typeref:struct:__anon2
seeker_sample_fops	main.c	/^static struct file_operations seeker_sample_fops;$/;"	v	typeref:struct:file_operations	file:
seeker_sample_log_init	main.c	/^static int seeker_sample_log_init(void)$/;"	f	file:
seeker_sample_log_read	io.c	/^ssize_t seeker_sample_log_read(struct file *file_ptr, char __user *buf, $/;"	f
seeker_sample_mdev	main.c	/^static struct miscdevice seeker_sample_mdev;$/;"	v	typeref:struct:miscdevice	file:
seeker_sample_open	io.c	/^int seeker_sample_open(struct inode *in, struct file * f)$/;"	f
seeker_sample_t	seeker.h	/^} seeker_sample_t; $/;"	t	typeref:struct:__anon3
seeker_sampler_entry_t	seeker.h	/^} seeker_sampler_entry_t;$/;"	t	typeref:struct:__anon5
seeker_sampler_exit	main.c	/^module_exit(seeker_sampler_exit);$/;"	v
seeker_sampler_exit	main.c	/^static void __exit seeker_sampler_exit(void)$/;"	f	file:
seeker_sampler_exit_handler	main.c	/^void seeker_sampler_exit_handler(void)$/;"	f
seeker_sampler_init	main.c	/^module_init(seeker_sampler_init);$/;"	v
seeker_sampler_init	main.c	/^static int __init seeker_sampler_init(void)$/;"	f	file:
total_cycles	seeker.h	/^	unsigned long long total_cycles;$/;"	m	struct:__anon4
type	seeker.h	/^	int type;$/;"	m	struct:__anon5
u	seeker.h	/^	} u;$/;"	m	struct:__anon5	typeref:union:__anon5::__anon6
warn	seeker.h	70;"	d
